#! /usr/bin/env perl
#
# Andrew Janke - a.janke@gmail.com
#
#
# A simple interface to SGE + PBS qsub interface for the unwashed
# Slightly modified to add the h_vmem parameter by Steffen Bollmann 2017-07-04 - Stebo85@web.de

use strict;
use warnings "all";
use Getopt::Long;
use Pod::Usage;
use File::Basename;
use IPC::Open2;
use Cwd;

# until I get organised and do this properly
my $PACKAGE = &basename($0);
my $VERSION = '1.4.0';
my $PACKAGE_BUGREPORT = '"Andrew Janke" <a.janke@gmail.com>';
 
my($me, %opt, @command, $script);

$me = &basename($0);
%opt = ('verbose' => 0,
        'fake' => 0,
        'script' => undef,
        'queue' => undef,
        'jname' => 'STDIN',
        'depends' => undef,
        'log' => undef,
        'man' => 0,
        'help' => 0,
	'resource_list' => "h_vmem=30G",
        'return_jid' => 0,
        );

# Check arguments
&GetOptions(
   'help|?' => \$opt{'help'},
   'man' => \$opt{'man'},
   'v|verbose' => \$opt{'verbose'},
   'version' => sub { &print_version_info },
   'f|fake' => \$opt{'fake'},
   's|script=s' => \$opt{'script'},
   'q|queue=s' => \$opt{'queue'},
   'N|name=s' => \$opt{'jname'},
   'd|depends=s' => \$opt{'depends'},
   'o|logfile=s' => \$opt{'logfile'},
   'l|resource_list=s' => \$opt{'resource_list'},
   'j|jid' => \$opt{'return_jid'},
   ) or pod2usage('-verbose' => 1) && exit;
   
# handle -man, -help or missing args
pod2usage('-verbose' => 1) if $opt{'help'};
pod2usage('-exitstatus' => 0, -verbose => 2) if $opt{'man'};
pod2usage('-verbose' => 0) && exit if ($#ARGV < 0);

# the remainder now has to be the command (we hope!)
@command = @ARGV;

# attempt to fortify quoting in the command
foreach (@command){
   # add quotes to arguments with spaces
   if(m/\ /){
      $_ = "\'$_\'";
      }
   }

my($pwd, @pwvalues, $shell, @deps, $stdout, $stderr);

# use QBATCH_QUEUE if defined and no queue set by arguments
if(!defined($opt{'queue'}) && defined($ENV{'QBATCH_QUEUE'})){
   $opt{'queue'} = $ENV{'QBATCH_QUEUE'};
   }

# Get current directory and user shell
$pwd = &cwd;
@pwvalues = getpwuid($<);
$shell = $pwvalues[8];

# clean up job name
$opt{'jname'} =~ s/(;|,|\s)/_/g;

# logfile
if(!defined($opt{'logfile'})){
   $opt{'logfile'} = "$pwd/$me-$$.log";
   }

# dependencies
@deps = (defined($opt{'depends'})) ? split(/\,/, $opt{'depends'}) : ();

chomp(my($submitted) = `date`);

# set up the script
$script = 
   "#! /bin/sh\n" .
   "#\n" .
   "# " . $ENV{'USER'} . " - " . `date` .
   "# This script was generated by $me\n" .
   "#\n" .

   # SGE syntax
   "# gridengine directives\n" .
   "#\$ -N $opt{'jname'}\n" .           # job name
   "#\$ -r y\n" .                       # rerun the job on fail
   "#\$ -S $shell\n" .                  # specify the shell

   "#\$ -j yes\n" .                     # join STDOUT and STDERR
   "#\$ -o $opt{'logfile'}\n" .         # logfile

   "#\$ -l $opt{'resource_list'}\n" .         # resource_list

   "#\$ -cwd\n" .                       # job is in the current directory
   "#\$ -V\n" .                         # export the current environment
   
   # queue
   ((defined($opt{'queue'})) ?
      "#\$ -q $opt{'queue'}\n" : "") .

   # dependencies
   (($#deps > -1) ?
      "#\$ -hold_jid " . join(',', @deps) . "\n" : "\n") .
   
   "\n" .

   # PBS syntax
   "# PBS directives\n" .
   "#PBS -r y\n" .                      # rerun the job on fail
   "#PBS -S $shell\n" .                 # specify the shell
   
   "#PBS -j oe\n" .                     # merge STDERR into STDOUT
   "#PBS -o $opt{'logfile'}\n" .        # logfile

   "#PBS -l $opt{'resource_list'}\n" .  # resource_list
	
   "#  PBS -V\n" .                        # export the current environment
   
   # job name (only 15 characters == fail)
   "#PBS -N " . substr($opt{'jname'}, 0, 15) . "\n" .
   
   # queue
   ((defined($opt{'queue'})) ?
      "#PBS -q $opt{'queue'}\n" : "") .
   
   # dependencies
   (($#deps > -1) ?
      "#PBS -W depend=afterany:" . join(':', @deps) . "\n" : "\n") .

   "\n" .

   "# Set the path as per the current user\n" .
   "export PATH=$ENV{'PATH'}\n" .
   "\n" .

   "# start logging\n" .
   "{\n" .
   
   # some logging output
   "echo \"## log from $me for $ENV{'USER'}\"\n" .
   "echo \"## \"\n" .
   "echo \"## ----------------------------------------------\"\n" .
   "echo \"## submitted:   $submitted\"\n" .
   "echo \"## started:     `date`\"\n" .
   "echo \"## host:        `uname -a`\"\n" .
   "echo \"## cwd:         $pwd\"\n" .
   "echo \"## command:     " . join(' ', @command) . "\"\n" .
   "echo \"## ----------------------------------------------\"\n" .
   "echo\n" .
   
   # finally the command itself
   "\n" .
   "# The command itself\n" .
   join(" ", @command) . "\n" .
   
   # record exit status
   "status=\$?\n\n" .
   
   # exit logging
   "echo\n" .
   "echo \"## ----------------------------------------------\"\n" .
   "echo \"## finished:     `date`\"\n" .
   "echo \"## exit status:  \$status\"\n" .
   "echo \"## ----------------------------------------------\"\n" .
   "echo\n" .
   "echo\n" .
   "\n" .

   # send to logfile
   "} > $opt{'logfile'} 2>&1\n";

print STDOUT "-----SCRIPT-----\n" . 
             $script .
             "----------------\n" if $opt{'verbose'};

# dump script
if(defined($opt{'script'})){
   open(FH, ">$opt{'script'}");
   print FH $script;
   close(FH);
   
   chmod(0700, $opt{'script'});
   }

# open a pipe to qsub and collect job id
if(!$opt{'fake'}){
   my($pid, $jid);
   
   $pid = open2(\*QSUB_OUT, \*QSUB_IN, 'qsub');
   print QSUB_IN $script;
   close(QSUB_IN);
   waitpid($pid, 0);

   my $buf = "";
   while (<QSUB_OUT>){
      $buf .= $_;
      ($jid) = $_ =~ m/(\d+)/;
      }
   
   if($opt{'return_jid'}){
      print STDOUT "$jid\n";
      }
   else{
      print STDOUT $buf;
      }
   }

sub print_version_info {
   print STDOUT "\n$PACKAGE version $VERSION\n".
                "Comments to $PACKAGE_BUGREPORT\n\n";
   exit;
   }


__END__

=head1 NAME

B<qbatch> - submits a command line to Grid Engine or PBS via qsub

=head1 SYNOPSIS

B<qbatch> [options] [B<-q> queue] [B<-l> h_vmem=30G] -- command

qbatch is designed to be inserted before any command that you would
usually run from the command line. In case of argument collision
where both your command and qbatch share an option such as --verbose
be sure to use the '--' syntax to split qbatch options from the 
commands options

   $ qbatch -l h_vmem=30G --verbose -- mincmath --verbose ...

By default qbatch sets the resource parameter h_vmem=30G. Adjust this to be twice as high as the real memory requirements of your job.

=head1 DESCRIPTION

B<qbatch> is a quick hack if you don't want to write a B<qsub> script

The idea is to just bung B<qbatch> in front of any command you would 
normally enter on the command line. (as per 'nice')

The output script is currently compatible with both gridengine and most
flavours of PBS

 eg:
    $ qbatch ls -F
    $ qbatch -q wb325.q@taylor -N job23 -- mincmath fred.mnc ..

If the environment variable QBATCH_QUEUE is defined, the job will
be sent to the defined queue.

Problems or comments should be sent to: a.janke@gmail.com

=head1 OPTIONS

=over 4

=item B<-v>, B<--verbose>

Be noisy when doing things (most importantly this will echo the resulting script to the terminal)

=item B<--version>

Print version number and exit

=item B<-h>, B<--help>

Dump some quick help output

=item B<--man>

Dump a man page

=item B<-f>, B<--fake>

Don't run anything, This is useful when combined with --verbose or --script

=item B<-s>, B<--script>

Output the batch script to the specified filename

=item B<-q>, B<--queue>

Specify a queue to run a job in. Use something like all.q@hostname to specify a particular host. 
Note that this will override anthing set by QBATCH_QUEUE in your environment.

=item B<-N>, B<--name>

Specify a job name to run the job as. By default this will be "STDIN"

=item B<-d>, B<--depends>

Specify a list of job dependencies by job name or number which have to run before this job will

=item B<-o>, B<--logfile>

Logfile for output of the command. By Default this will make a file in the current directory called 
qbatch-<PID>.log where PID is the Process ID of the instance of qbatch

=item B<-l>, B<--resource_list>

Resource List parameters. By Default this will be h_vmem=30G - change to smaller or larger values 
depending on the memory usage of your application


=item B<-j>, B<--jid>

return only the job id of the submitted job on STDOUT

=back

=head1 SEE ALSO

qsub(1) qdel(1)

=head1 AUTHOR

Andrew Janke - a.janke@gmail.com

=cut
